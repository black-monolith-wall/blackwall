<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ULTRA CHAOSDIVERS - ORBITAL DOMINANCE!</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Orbitron', sans-serif;
        }

        .container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #particleCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .text-container {
            position: relative;
            z-index: 2;
            text-align: center;
        }

        #chantText {
            color: #ff0000;
            font-size: 4rem;
            text-transform: uppercase;
            text-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000, 0 0 60px #ff0000;
            opacity: 0;
            transition: opacity 0.5s ease, transform 0.5s ease;
            transform: scale(1);
        }

        #chantText.active {
            opacity: 1;
            transform: scale(1.2) translateY(-10px);
        }

        #chantText.fade {
            opacity: 0;
            transform: scale(0.8) translateY(10px);
        }

        #toggleButton {
            position: fixed;
            bottom: 20px;
            z-index: 3;
            padding: 12px 25px;
            font-size: 1.3rem;
            background: #ff0000;
            color: #000;
            border: 3px solid #ffa500;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            transition: background 0.3s, border-color 0.3s, transform 0.2s;
            box-shadow: 0 0 15px #ff0000;
        }

        #toggleButton:hover {
            background: #cc0000;
            border-color: #ff0000;
            transform: scale(1.05);
        }

        @media (max-width: 768px) {
            #chantText {
                font-size: 2.5rem;
            }
            #toggleButton {
                font-size: 1.1rem;
                padding: 10px 20px;
            }
        }

        @media (max-width: 480px) {
            #chantText {
                font-size: 1.8rem;
            }
            #toggleButton {
                font-size: 0.9rem;
                padding: 8px 16px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="particleCanvas"></canvas>
        <div class="text-container">
            <div id="chantText"></div>
        </div>
        <button id="toggleButton">Call In Support!</button>
    </div>
    <script>
        // Updated chant lines as requested
        const chantLines = [
            "HEART - CLEAR",
            "FATE - NEAR",
            "STOKE - FEAR",
            "LET IT BURN!",
            "HEART - CLEAR",
            "FATE - NEAR",
            "STOKE - FEAR",
            "LET IT BURN!",
            "ROGUE V",
            "FREEDOM MUST REVIVE",
            "CHAOS REIGNS",
            "VERA LIBERTAS!",
            "ROGUE V",
            "FREEDOM MUST REVIVE",
            "CHAOS REIGNS",
            "VERA LIBERTAS!"
        ];

        const chantText = document.getElementById('chantText');
        const toggleButton = document.getElementById('toggleButton');
        const canvas = document.getElementById('particleCanvas');
        const ctx = canvas.getContext('2d');

        let currentIndex = 0;
        let isPlaying = false;

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Re-initialize stars on resize to redistribute them
            starParticles.length = 0;
            initStarParticles();
        });

        // --- Planet Surface and Horizon Constants ---
        const GROUND_HEIGHT = 100; // Height of the ground from the bottom of the canvas
        const GROUND_COLOR = 'rgba(140, 100, 110, 1)'; // Dark red for the ground
        const HORIZON_OFFSET_FROM_GROUND = 150; // How far the horizon line is above the ground top
        const HORIZON_COLOR = 'rgba(100, 100, 150, 0.5)'; // Lighter grey for the horizon
        const HORIZON_THICKNESS = 3; // Thickness of the horizon line

        // Helper function for drawing triangles
        function drawTriangle(x1, y1, x2, y2, x3, y3, color) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x3, y3);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
        }

        // --- Star Background Particles ---
        const starParticles = [];
        const NUM_STARS = 300; // Total number of stars

        // Star colors for galaxy effect
        const starColors = [
            'rgba(255, 255, 255, ', // White
            'rgba(180, 200, 255, ', // Pale blue
            'rgba(255, 240, 180, ', // Pale yellow
            'rgba(255, 180, 180, '  // Faint pink/red
        ];

        class StarParticle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 1.5 + 0.5; // Small stars
                this.baseOpacity = Math.random() * 0.3 + 0.1; // Faint base opacity
                this.opacity = this.baseOpacity;
                this.blinkSpeed = Math.random() * 0.02 + 0.01; // Slower blinking
                this.blinkDirection = Math.random() < 0.5 ? 1 : -1; // Random initial blink direction
                this.color = color; // Assign the chosen color
            }

            update() {
                this.opacity += this.blinkDirection * this.blinkSpeed;
                if (this.opacity > 0.8 || this.opacity < this.baseOpacity) {
                    this.blinkDirection *= -1;
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.color + this.opacity + ')'; // Use dynamic color
                ctx.fill();
            }
        }

        function initStarParticles() {
            const minStarY = 0; // Top of the canvas
            const maxStarY = canvas.height - GROUND_HEIGHT - HORIZON_OFFSET_FROM_GROUND - 50; // Just above the horizon

            // Define the vertical band for the Milky Way effect
            const milkyWayBandHeight = (maxStarY - minStarY) * 0.6; // 60% of the available sky height
            const milkyWayBandCenterY = minStarY + (maxStarY - minStarY) / 2;
            const milkyWayBandTop = milkyWayBandCenterY - milkyWayBandHeight / 2;
            const milkyWayBandBottom = milkyWayBandCenterY + milkyWayBandHeight / 2;


            for (let i = 0; i < NUM_STARS; i++) {
                let x = Math.random() * canvas.width; // Evenly spread across width
                let y = milkyWayBandTop + Math.random() * milkyWayBandHeight; // Evenly spread within the band

                // Ensure stars are within canvas bounds and above the horizon
                x = Math.max(0, Math.min(canvas.width, x));
                y = Math.max(minStarY, Math.min(maxStarY, y));

                // Pick a random color for the star
                const color = starColors[Math.floor(Math.random() * starColors.length)];
                starParticles.push(new StarParticle(x, y, color));
            }
        }

        // --- Orbital Destroyer (Modified for continuous movement and strike origin!) ---
        const orbitalDestroyers = [];
        const MAX_DESTROYERS = 3; // Keep a few destroyers in rotation
        const DESTROYER_FIRE_COOLDOWN_MS = 1500; // 1.5 seconds cooldown after firing

        class OrbitalDestroyer {
            constructor() {
                this.width = Math.random() * 60 + 100; // Varying destroyer sizes, slightly larger
                this.height = this.width / 4;
                this.y = Math.random() * (canvas.height * 0.15) + (canvas.height * 0.02); // Top 2-17% of screen
                this.speed = Math.random() * 0.8 + 0.5; // Slightly faster movement
                this.opacity = 0.9;
                this.x = -this.width; // Start off-screen left
                this.lastFiredTime = 0; // Timestamp of last fire
                this.engineGlowStrength = 0; // For pulsing glow
                this.glowDirection = 1; // 1 for increasing, -1 for decreasing
            }

            isAvailable() {
                return (Date.now() - this.lastFiredTime) > DESTROYER_FIRE_COOLDOWN_MS;
            }

            update() {
                this.x += this.speed;
                if (this.x > canvas.width + this.width) {
                    // Wrap around: reset position to left, new y, and make it ready to fire again
                    this.x = -this.width;
                    this.y = Math.random() * (canvas.height * 0.15) + (canvas.height * 0.02);
                    this.lastFiredTime = 0; // Reset fire cooldown on wrap-around
                }

                // Update engine glow
                this.engineGlowStrength += this.glowDirection * 0.05;
                if (this.engineGlowStrength > 1 || this.engineGlowStrength < 0) {
                    this.glowDirection *= -1;
                }
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;

                // Main body gradient
                const bodyGradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y + this.height);
                bodyGradient.addColorStop(0, 'rgba(60, 60, 60, 1)');
                bodyGradient.addColorStop(0.5, 'rgba(100, 100, 100, 1)');
                bodyGradient.addColorStop(1, 'rgba(60, 60, 60, 1)');
                ctx.fillStyle = bodyGradient;

                // Main body
                ctx.beginPath();
                ctx.moveTo(this.x + this.width * 0.1, this.y); // Start after nose
                ctx.lineTo(this.x + this.width, this.y);
                ctx.lineTo(this.x + this.width, this.y + this.height);
                ctx.lineTo(this.x, this.y + this.height);
                ctx.closePath();
                ctx.fill();

                // Nose (triangle)
                drawTriangle(
                    this.x, this.y + this.height,
                    this.x + this.width * 0.1, this.y,
                    this.x, this.y,
                    bodyGradient // Use same gradient for nose
                );

                // Cockpit/Bridge (lighter grey gradient)
                const cockpitGradient = ctx.createLinearGradient(this.x + this.width * 0.7, this.y - this.height * 0.5, this.x + this.width * 0.9, this.y + this.height * 0.3);
                cockpitGradient.addColorStop(0, 'rgba(150, 150, 150, 1)');
                cockpitGradient.addColorStop(1, 'rgba(90, 90, 90, 1)');
                ctx.fillStyle = cockpitGradient;
                ctx.fillRect(this.x + this.width * 0.7, this.y - this.height * 0.5, this.width * 0.2, this.height * 0.8);

                // Subtle panels
                ctx.fillStyle = 'rgba(40, 40, 40, 0.8)';
                ctx.fillRect(this.x + this.width * 0.3, this.y + this.height * 0.1, this.width * 0.05, this.height * 0.3);
                ctx.fillRect(this.x + this.width * 0.5, this.y + this.height * 0.6, this.width * 0.07, this.height * 0.2);

                // Engines (red glow, pulsing)
                const engineGlow = `rgba(255, 0, 0, ${0.5 + this.engineGlowStrength * 0.5})`;
                ctx.fillStyle = engineGlow;
                ctx.shadowBlur = 15 + this.engineGlowStrength * 10;
                ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';

                ctx.fillRect(this.x + this.width * 0.02, this.y + this.height, this.width * 0.1, this.height * 0.3);
                ctx.fillRect(this.x + this.width * 0.88, this.y + this.height, this.width * 0.1, this.height * 0.3);

                ctx.shadowBlur = 0; // Reset shadow blur

                ctx.restore();
            }
        }

        function initDestroyers() {
            for (let i = 0; i < MAX_DESTROYERS; i++) {
                const destroyer = new OrbitalDestroyer();
                // Stagger initial positions
                destroyer.x = -destroyer.width - (i * (canvas.width / MAX_DESTROYERS));
                orbitalDestroyers.push(destroyer);
            }
        }

        // --- Explosive Particle System ---
        const explosions = [];
        const smokeParticles = [];
        const debrisParticles = [];
        const incomingProjectiles = []; // Holds BombProjectiles and NapalmMissiles
        const railgunLines = []; // Holds RailgunLines
        const napalmBubbles = [];
        const fireTrails = []; // Holds fire trail particles
        const burnMarks = []; // Holds temporary burn marks from lasers
        const swarmlings = []; // Holds Alien Swarmlings
        const gooParticles = []; // New: Holds goo particles

        const SWARMLING_SPAWN_INTERVAL = 5000; // Spawn a new swarmling every 5 seconds
        const BIG_SWARMLING_SPAWN_INTERVAL = 8000; // Spawn a big swarmling every 8 seconds
        let lastSwarmlingSpawnTime = 0;
        let lastBigSwarmlingSpawnTime = 0;
        const SWARMLING_DESTROY_RADIUS = 30; // Radius for ordnance to destroy swarmlings

        class ExplosionParticle {
            constructor(x, y, color, speed, size) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = size || Math.random() * 5 + 2;
                this.speedX = (Math.random() * 2 - 1) * speed;
                this.speedY = (Math.random() * 2 - 1) * speed;
                this.opacity = 1;
                this.gravity = 0.1;
                this.lifetime = Math.random() * 60 + 30;
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.speedY += this.gravity;
                this.opacity -= 1 / this.lifetime;
                this.size *= 0.98;
            }

            draw() {
                if (this.opacity > 0 && this.size > 0.5) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = this.color + this.opacity + ')';
                    ctx.fill();
                }
            }
        }

        // Smoke Particle (for general explosions)
        class SmokeParticle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color || 'rgba(100, 100, 100, ';
                this.size = Math.random() * 20 + 10;
                this.speedX = (Math.random() * 1 - 0.5) * 0.5;
                this.speedY = (Math.random() * 1 - 0.5) * 0.5 - 0.2;
                this.opacity = 0.5;
                this.lifetime = Math.random() * 100 + 80;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() * 0.05 - 0.025);
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.opacity -= 1 / this.lifetime;
                this.size *= 1.01;
                this.rotation += this.rotationSpeed;
            }

            draw() {
                if (this.opacity > 0 && this.size > 0.5) {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotation);
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = this.color + this.opacity + ')';
                    ctx.fill();
                    ctx.restore();
                }
            }
        }

        class DebrisParticle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color || 'rgba(150, 150, 150, ';
                this.size = Math.random() * 3 + 1;
                this.speedX = (Math.random() * 4 - 2);
                this.speedY = (Math.random() * 4 - 2);
                this.opacity = 1;
                this.gravity = 0.2;
                this.lifetime = Math.random() * 40 + 20;
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.speedY += this.gravity;
                this.opacity -= 1 / this.lifetime;
                this.size *= 0.95;
            }

            draw() {
                if (this.opacity > 0 && this.size > 0.5) {
                    ctx.beginPath();
                    ctx.rect(this.x, this.y, this.size, this.size);
                    ctx.fillStyle = this.color + this.opacity + ')';
                    ctx.fill();
                }
            }
        }

        // New: Goo Particle for swarmling destruction
        class GooParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 4 + 2;
                this.speedX = (Math.random() * 2 - 1) * 1.5;
                this.speedY = (Math.random() * 2 - 1) * 1.5;
                this.opacity = 1;
                this.gravity = 0.05; // Less gravity, more floaty
                this.lifetime = Math.random() * 40 + 30;
                this.color = `rgba(${Math.floor(Math.random() * 50)}, ${Math.floor(Math.random() * 150 + 100)}, ${Math.floor(Math.random() * 50)}, `; // Greenish goo
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.speedY += this.gravity;
                this.opacity -= 1 / this.lifetime;
                this.size *= 0.97;
            }

            draw() {
                if (this.opacity > 0 && this.size > 0.5) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = this.color + this.opacity + ')';
                    ctx.fill();
                }
            }
        }

        // New class for Alien Swarmling (Triangle)
        class AlienSwarmling {
            constructor() {
                this.size = Math.random() * 15 + 10; // Size of the triangle
                this.x = Math.random() * canvas.width;
                this.y = canvas.height + this.size; // Start below ground
                this.speedY = Math.random() * 0.8 + 0.5; // Speed of burrowing up
                this.speedX = (Math.random() * 1 - 0.5) * 0.5; // Slight horizontal drift
                this.opacity = 0; // Start invisible
                this.state = 'burrowing'; // 'burrowing', 'active'
                this.lifetime = Math.random() * 300 + 200; // How long it stays active
                this.currentLife = 0;
                this.color = `rgba(${Math.floor(Math.random() * 50)}, ${Math.floor(Math.random() * 150 + 100)}, ${Math.floor(Math.random() * 50)}, `; // Greenish alien color
                this.markedForRemoval = false; // New flag for immediate removal
            }

            update() {
                if (this.markedForRemoval) return true; // Indicate it's ready to be removed

                if (this.state === 'burrowing') {
                    this.y -= this.speedY;
                    this.opacity += 0.01; // Fade in as it burrows up
                    if (this.y <= canvas.height - GROUND_HEIGHT) { // Reached surface
                        this.y = canvas.height - GROUND_HEIGHT;
                        this.state = 'active';
                        this.opacity = 1;
                    }
                } else if (this.state === 'active') {
                    this.x += this.speedX;
                    this.currentLife++;
                    if (this.currentLife > this.lifetime) {
                        this.destroy(); // Destroy itself if lifetime exceeded
                    }
                }
                return false; // Not ready for removal yet
            }

            draw() {
                if (this.opacity > 0 && !this.markedForRemoval) {
                    ctx.save();
                    ctx.globalAlpha = this.opacity;
                    // Draw a triangle
                    drawTriangle(
                        this.x, this.y - this.size, // Top point
                        this.x - this.size / 2, this.y, // Bottom-left
                        this.x + this.size / 2, this.y, // Bottom-right
                        this.color + this.opacity + ')'
                    );
                    ctx.restore();
                }
            }

            destroy() {
                if (!this.markedForRemoval) {
                    this.markedForRemoval = true;
                    // Create goo particles instead of explosion
                    const numGoo = Math.random() * 15 + 10;
                    for (let i = 0; i < numGoo; i++) {
                        gooParticles.push(new GooParticle(this.x, this.y));
                    }
                }
            }
        }

        // New class for Big Swarmling (Square)
        class BigSwarmling {
            constructor() {
                this.size = Math.random() * 30 + 20; // Larger size
                this.side = Math.random() < 0.5 ? 'left' : 'right'; // Spawn from left or right
                this.x = this.side === 'left' ? -this.size : canvas.width + this.size;
                this.y = canvas.height - GROUND_HEIGHT - (this.size / 2); // On the ground
                this.speedX = (Math.random() * 0.5 + 0.3) * (this.side === 'left' ? 1 : -1); // Slower, consistent horizontal movement
                this.opacity = 1;
                this.state = 'active'; // Always active, no burrowing
                this.color = `rgba(${Math.floor(Math.random() * 50)}, ${Math.floor(Math.random() * 100 + 50)}, ${Math.floor(Math.random() * 150 + 100)}, `; // Bluish alien color
                this.markedForRemoval = false;
            }

            update() {
                if (this.markedForRemoval) return true;

                this.x += this.speedX;
                // Remove if off-screen
                if (this.side === 'left' && this.x > canvas.width + this.size) {
                    return true;
                }
                if (this.side === 'right' && this.x < -this.size) {
                    return true;
                }
                return false;
            }

            draw() {
                if (this.opacity > 0 && !this.markedForRemoval) {
                    ctx.save();
                    ctx.globalAlpha = this.opacity;
                    ctx.fillStyle = this.color + this.opacity + ')';
                    ctx.fillRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
                    ctx.restore();
                }
            }

            destroy() {
                if (!this.markedForRemoval) {
                    this.markedForRemoval = true;
                    // Create goo particles instead of explosion
                    const numGoo = Math.random() * 25 + 15;
                    for (let i = 0; i < numGoo; i++) {
                        gooParticles.push(new GooParticle(this.x, this.y));
                    }
                }
            }
        }


        // Railgun Line (Originates from Destroyer)
        class RailgunLine {
            constructor(startX, startY, targetX, targetY) { // Added targetY
                this.startX = startX;
                this.startY = startY;
                this.targetX = targetX; // Now targetX and targetY are set dynamically
                this.targetY = targetY;
                this.opacity = 1;
                this.lifetime = 10;
                this.width = Math.random() * 5 + 3;
                this.color = 'rgba(100, 255, 255, ';
                this.hit = false;
            }

            update() {
                this.opacity -= 1 / this.lifetime;
                if (!this.hit) {
                    createExplosion(this.targetX, this.targetY, 'railgun'); // Use targetX, targetY for explosion
                    // Check for swarmling destruction
                    for (let i = swarmlings.length - 1; i >= 0; i--) {
                        const swarmling = swarmlings[i];
                        if (swarmling.state === 'active' && !swarmling.markedForRemoval) { // Only destroy active swarmlings not already marked
                            const dist = Math.sqrt(Math.pow(this.targetX - swarmling.x, 2) + Math.pow(this.targetY - swarmling.y, 2));
                            if (dist < SWARMLING_DESTROY_RADIUS + swarmling.size) {
                                swarmling.destroy();
                            }
                        }
                    }
                    this.hit = true;
                }
            }

            draw() {
                if (this.opacity > 0) {
                    ctx.beginPath();
                    ctx.moveTo(this.startX, this.startY);
                    ctx.lineTo(this.targetX, this.targetY);
                    ctx.strokeStyle = this.color + this.opacity + ')';
                    ctx.lineWidth = this.width;
                    ctx.lineCap = 'round';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = 'rgba(100, 255, 255, 1)';
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            }
        }

        // Bomb Projectile (Originates from Destroyer)
        class BombProjectile {
            constructor(startX, startY, targetX, targetY) {
                this.x = startX;
                this.y = startY;
                this.targetX = targetX;
                this.targetY = targetY;
                this.speed = 8;
                this.color = 'rgba(255, 100, 0, '; // Bomb color (orange/yellow for explosion)
                this.size = 8;
                this.opacity = 1;
                this.hit = false;

                const dx = targetX - startX;
                const dy = targetY - startY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                this.velX = (dx / distance) * this.speed;
                this.velY = (dy / distance) * this.speed;
                this.angle = Math.atan2(this.velY, this.velX);
            }

            update() {
                if (this.hit) return;
                this.x += this.velX;
                this.y += this.velY;
                this.opacity -= 0.005;

                if (this.y >= this.targetY - this.size && !this.hit) {
                    this.hit = true;
                    createExplosion(this.x, this.y, 'bomb'); // Create bomb explosion
                    // Check for swarmling destruction
                    for (let i = swarmlings.length - 1; i >= 0; i--) {
                        const swarmling = swarmlings[i];
                        if (swarmling.state === 'active' && !swarmling.markedForRemoval) { // Only destroy active swarmlings not already marked
                            const dist = Math.sqrt(Math.pow(this.x - swarmling.x, 2) + Math.pow(this.y - swarmling.y, 2));
                            if (dist < SWARMLING_DESTROY_RADIUS + swarmling.size) {
                                swarmling.destroy();
                            }
                        }
                    }
                    this.opacity = 0;
                }
            }

            draw() {
                if (this.opacity > 0 && !this.hit) {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.angle);

                    // Simple bomb shape (dark grey sphere)
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(100, 100, 100, ' + this.opacity + ')';
                    ctx.fill();

                    // Small fiery trail for bomb
                    ctx.beginPath();
                    ctx.arc(-this.size * 1.5, 0, this.size * (0.8 + Math.random() * 0.2) * 0.5, 0, Math.PI * 2);
                    ctx.fillStyle = this.color.replace('rgba', 'rgb') + (this.opacity * (0.5 + Math.random() * 0.5)) + ')';
                    ctx.shadowBlur = this.size * 0.5;
                    ctx.shadowColor = this.color.replace('rgba', 'rgb') + '0.8)';
                    ctx.fill();
                    ctx.shadowBlur = 0;

                    ctx.restore();
                }
            }
        }

        // Napalm Missile (Originates from Destroyer)
        class NapalmMissile {
            constructor(startX, startY, targetX, targetY) {
                this.x = startX;
                this.y = startY;
                this.targetX = targetX;
                this.targetY = targetY;
                this.speed = 8;
                this.color = 'rgba(255, 50, 0, '; // Napalm color
                this.size = 10;
                this.opacity = 1;
                this.hit = false;

                const dx = targetX - startX;
                const dy = targetY - startY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                this.velX = (dx / distance) * this.speed;
                this.velY = (dy / distance) * this.speed;
                this.angle = Math.atan2(this.velY, this.velX);
            }
            update() {
                if (this.hit) return;
                this.x += this.velX;
                this.y += this.velY;
                this.opacity -= 0.005;
                if (this.y >= this.targetY - this.size && !this.hit) {
                    this.hit = true;
                    const numBubbles = Math.random() * 20 + 15;
                    for (let i = 0; i < numBubbles; i++) {
                        const bubbleX = this.x + (Math.random() * 80 - 40);
                        const bubbleY = this.y + (Math.random() * 50 - 25);
                        napalmBubbles.push(new NapalmBubble(bubbleX, bubbleY));
                    }
                    // Check for swarmling destruction
                    for (let i = swarmlings.length - 1; i >= 0; i--) {
                        const swarmling = swarmlings[i];
                        if (swarmling.state === 'active' && !swarmling.markedForRemoval) { // Only destroy active swarmlings not already marked
                            const dist = Math.sqrt(Math.pow(this.x - swarmling.x, 2) + Math.pow(this.y - swarmling.y, 2));
                            if (dist < SWARMLING_DESTROY_RADIUS + swarmling.size) {
                                swarmling.destroy();
                            }
                        }
                    }
                    this.opacity = 0;
                }
            }
            draw() {
                if (this.opacity > 0 && !this.hit) {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.angle);

                    ctx.beginPath();
                    ctx.rect(-this.size * 1.5, -this.size / 2, this.size * 3, this.size);
                    ctx.fillStyle = 'rgba(150, 150, 150, ' + this.opacity + ')';
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(this.size * 1.5, -this.size / 2);
                    ctx.lineTo(this.size * 2.5, 0);
                    ctx.lineTo(this.size * 1.5, this.size / 2);
                    ctx.fillStyle = 'rgba(180, 180, 180, ' + this.opacity + ')';
                    ctx.fill();

                    ctx.beginPath();
                    ctx.arc(-this.size * 1.5, 0, this.size * (0.8 + Math.random() * 0.2), 0, Math.PI * 2);
                    ctx.fillStyle = this.color.replace('rgba', 'rgb') + (this.opacity * (0.5 + Math.random() * 0.5)) + ')';
                    ctx.shadowBlur = this.size;
                    ctx.shadowColor = this.color.replace('rgba', 'rgb') + '0.8)';
                    ctx.fill();
                    ctx.shadowBlur = 0;

                    ctx.restore();
                }
            }
        }

        class NapalmBubble {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 10 + 5;
                this.speedX = (Math.random() * 1 - 0.5) * 0.5;
                this.speedY = (Math.random() * 1 - 0.5) * 0.5 - 0.1;
                this.opacity = 1;
                this.colorStage = 0;
                this.lifetimeFiery = Math.random() * 60 + 40;
                this.lifetimeSmoke = Math.random() * 100 + 80;
                this.currentFrame = 0;
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.currentFrame++;

                if (this.colorStage === 0) {
                    this.opacity -= (1 / this.lifetimeFiery);
                    this.size *= 1.01;
                    if (this.currentFrame >= this.lifetimeFiery) {
                        this.colorStage = 1;
                        this.opacity = 0.5;
                        this.currentFrame = 0;
                    }
                } else if (this.colorStage === 1) {
                    this.color = 'rgba(40, 40, 40, ';
                    this.opacity -= (1 / this.lifetimeSmoke);
                    this.size *= 1.005;
                }
            }

            draw() {
                if (this.opacity > 0 && this.size > 0.5) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    if (this.colorStage === 0) {
                        const r = 255;
                        const g = Math.floor(Math.random() * 100 + 50);
                        const b = 0;
                        ctx.fillStyle = `rgba(${r},${g},${b},${this.opacity})`;
                        ctx.shadowBlur = this.size / 2;
                        ctx.shadowColor = `rgba(${r},${g},${b},${this.opacity * 0.8})`;
                    } else {
                        ctx.fillStyle = this.color + this.opacity + ')';
                        ctx.shadowBlur = 0;
                    }
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
        }

        // Fire Trail Particle
        class FireTrailParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 8 + 4;
                this.color = 'rgba(255, ' + (Math.random() * 100) + ', 0, '; // Orange to Yellow
                this.opacity = 1;
                this.lifetime = Math.random() * 50 + 50; // Controls how long they last (approx 5-10 seconds at 60fps)
                this.speedX = (Math.random() - 0.5) * 0.5; // Slight horizontal drift
                this.speedY = (Math.random() * 0.5 + 0.1); // Slowly rise
                this.shrinkRate = 0.98; // Shrink slowly
            }

            update() {
                this.x += this.speedX;
                this.y -= this.speedY; // Rise
                this.opacity -= 1 / this.lifetime;
                this.size *= this.shrinkRate;
            }

            draw() {
                if (this.opacity > 0 && this.size > 0.5) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = this.color + this.opacity + ')';
                    ctx.fill();
                }
            }
        }

        // Burn Mark (new class for laser ground impact)
        class BurnMark {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = Math.random() * 10 + 15; // Initial size
                this.opacity = 0.8;
                this.lifetime = Math.random() * 120 + 100; // How long it lasts in frames
                this.color = 'rgba(50, 0, 0, '; // Dark red/brown
            }

            update() {
                this.opacity -= 1 / this.lifetime;
                this.radius *= 0.99; // Slightly shrink
            }

            draw() {
                if (this.opacity > 0 && this.radius > 1) {
                    ctx.beginPath();
                    ctx.ellipse(this.x, this.y, this.radius, this.radius * 0.5, 0, 0, Math.PI * 2);
                    ctx.fillStyle = this.color + this.opacity + ')';
                    ctx.fill();
                }
            }
        }

        // Orbital Laser Beam (Originates from Destroyer)
        class OrbitalLaser {
            constructor(destroyer, targetX, targetY, durationFrames) { // Added targetY
                this.destroyer = destroyer;
                this.startX = destroyer.x + destroyer.width / 2;
                this.startY = destroyer.y + destroyer.height / 2;
                this.baseTargetX = targetX; // Initial X target
                this.baseTargetY = targetY; // Initial Y target
                this.width = 15;
                this.color = 'rgba(255, 0, 0, ';
                this.opacity = 1;
                this.lifetime = durationFrames;
                this.currentLife = 0;
                this.trailInterval = 3;
                this.trailCounter = 0;
                this.burnMarkInterval = 5; // How often to create burn marks
                this.burnMarkCounter = 0;

                // Laser pathing
                this.pathType = Math.random() < 0.5 ? 'zigzag' : 'straight'; // Randomly choose path type
                this.zigZagAmplitude = Math.random() * 100 + 50; // Max horizontal deviation
                this.zigZagFrequency = Math.random() * 0.1 + 0.05; // How fast it zig-zags
                this.pathSpeed = (Math.random() * 0.5 + 0.5) * (Math.random() < 0.5 ? 1 : -1); // Speed and direction of straight path
            }

            update() {
                this.currentLife++;
                this.opacity = 1 - (this.currentLife / this.lifetime);
                this.width = 15 + (Math.sin(this.currentLife * 0.2) * 8);

                // Laser beam origin follows the destroyer's X
                this.startX = this.destroyer.x + this.destroyer.width / 2;

                // Calculate dynamic targetX based on path type
                let currentTargetX = this.baseTargetX;
                if (this.pathType === 'zigzag') {
                    currentTargetX += Math.sin(this.currentLife * this.zigZagFrequency) * this.zigZagAmplitude;
                } else { // 'straight'
                    currentTargetX += this.currentLife * this.pathSpeed;
                }
                // Clamp targetX to canvas boundaries
                this.targetX = Math.max(0, Math.min(canvas.width, currentTargetX));
                this.targetY = this.baseTargetY; // Laser always targets the initial Y, even if X changes

                this.trailCounter++;
                if (this.trailCounter % this.trailInterval === 0) {
                    const trailX = this.targetX + (Math.random() * this.width - this.width / 2);
                    const trailY = this.targetY;
                    fireTrails.push(new FireTrailParticle(trailX, trailY));
                }

                this.burnMarkCounter++;
                if (this.burnMarkCounter % this.burnMarkInterval === 0) {
                    // Create a burn mark at the current laser impact point
                    burnMarks.push(new BurnMark(this.targetX, this.targetY));

                    // Check for swarmling destruction along the laser's impact point
                    for (let i = swarmlings.length - 1; i >= 0; i--) {
                        const swarmling = swarmlings[i];
                        if (swarmling.state === 'active' && !swarmling.markedForRemoval) { // Only destroy active swarmlings not already marked
                            const dist = Math.sqrt(Math.pow(this.targetX - swarmling.x, 2) + Math.pow(this.targetY - swarmling.y, 2));
                            if (dist < SWARMLING_DESTROY_RADIUS + swarmling.size) {
                                swarmling.destroy();
                            }
                        }
                    }
                }
            }

            draw() {
                if (this.opacity > 0) {
                    ctx.beginPath();
                    ctx.moveTo(this.startX, this.startY); // Origin from destroyer
                    ctx.lineTo(this.targetX, this.targetY); // Dynamic target on ground
                    ctx.strokeStyle = this.color + this.opacity + ')';
                    ctx.lineWidth = this.width; // Use this.width for beam thickness
                    ctx.lineCap = 'round';
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = 'rgba(255, 50, 50, 1)'; // Red glow
                    ctx.stroke(); // Use stroke for line
                    ctx.shadowBlur = 0;
                }
            }
        }

        let activeLaser = null; // Only one active laser at a time

        function createExplosion(x, y, type) {
            const numParticles = 80; // Default for bomb/railgun
            const explosionColor = {
                'bomb': 'rgba(255, 165, 0, ',
                'railgun': 'rgba(100, 255, 255, ',
                'massive': 'rgba(255, 255, 0, ',
                // 'swarmling_death' now handled by GooParticle directly
            }[type];
            const smokeColor = 'rgba(60, 60, 60, ';
            const debrisColor = 'rgba(100, 100, 100, ';

            // Only create explosion/smoke/debris for non-swarmling types
            if (type !== 'swarmling_death') {
                // Initial explosion particles
                for (let i = 0; i < numParticles; i++) {
                    explosions.push(new ExplosionParticle(x, y, explosionColor + (Math.random() * 0.5 + 0.5), Math.random() * 4 + 2, Math.random() * 5 + 2));
                }

                // Smoke
                for (let i = 0; i < numParticles / 2; i++) {
                    smokeParticles.push(new SmokeParticle(x, y, smokeColor));
                }

                // Debris for bomb and railgun
                if (type === 'bomb' || type === 'railgun') {
                    for (let i = 0; i < numParticles / 4; i++) {
                        debrisParticles.push(new DebrisParticle(x, y, debrisColor));
                    }
                }
            }

            // Check for swarmling destruction if it's a general explosion (bomb, napalm, massive)
            // Railgun and Laser already handle swarmling destruction in their update methods
            if (type === 'bomb' || type === 'napalm' || type === 'massive') {
                for (let i = swarmlings.length - 1; i >= 0; i--) {
                    const swarmling = swarmlings[i];
                    if (swarmling.state === 'active' && !swarmling.markedForRemoval) {
                        const dist = Math.sqrt(Math.pow(x - swarmling.x, 2) + Math.pow(y - swarmling.y, 2));
                        if (dist < SWARMLING_DESTROY_RADIUS + swarmling.size) {
                            swarmling.destroy();
                        }
                    }
                }
            }
        }

        function triggerOrbitalStrike(type) {
            // Find an active swarmling to target, if any
            let targetSwarmling = swarmlings.find(s => s.state === 'active' && !s.markedForRemoval);
            let targetX, targetY;

            // Define the surface target area: from the horizon down to the top of the ground
            const minSurfaceY = canvas.height - GROUND_HEIGHT - HORIZON_OFFSET_FROM_GROUND;
            const maxSurfaceY = canvas.height - (GROUND_HEIGHT * 0.5); // Target slightly above middle of ground

            if (targetSwarmling && (type === 'railgun' || type === 'laser')) {
                // If a swarmling exists and it's a railgun or laser, target the swarmling
                targetX = targetSwarmling.x;
                targetY = targetSwarmling.y;
            } else {
                // Otherwise, target a random spot on the surface
                targetX = Math.random() * canvas.width;
                targetY = minSurfaceY + Math.random() * (maxSurfaceY - minSurfaceY);
            }

            const availableDestroyer = orbitalDestroyers.find(d => d.isAvailable());

            if (!availableDestroyer && type !== 'massive') {
                console.log("No destroyer available to fire " + type + " strike.");
                return;
            }

            if (type !== 'massive') {
                availableDestroyer.lastFiredTime = Date.now();
            }

            if (type === 'railgun') {
                const startX = availableDestroyer.x + availableDestroyer.width / 2;
                const startY = availableDestroyer.y + availableDestroyer.height / 2;
                // Railgun targets the calculated targetX, targetY
                railgunLines.push(new RailgunLine(startX, startY, targetX, targetY));
            } else if (type === 'laser') {
                const laserDuration = Math.random() * 300 + 300;
                // Laser targets the calculated targetX, targetY
                activeLaser = new OrbitalLaser(availableDestroyer, targetX, targetY, laserDuration);
            } else if (type === 'napalm') {
                const startX = availableDestroyer.x + availableDestroyer.width / 2;
                const startY = availableDestroyer.y + availableDestroyer.height / 2;
                // Napalm targets directly on the ground or very slightly above
                incomingProjectiles.push(new NapalmMissile(startX, startY, targetX, targetY));
            } else if (type === 'bomb') {
                const startX = availableDestroyer.x + availableDestroyer.width / 2;
                const startY = availableDestroyer.y + availableDestroyer.height / 2;

                // For bombs, introduce a random chance for an airburst
                const isAirburst = Math.random() < 0.3; // 30% chance for an airburst
                let bombTargetY = targetY; // Default to surface target

                if (isAirburst) {
                    // Airburst above the horizon, within the upper half of the ground height offset.
                    // This creates explosions in the "sky" but still relatively low.
                    const airburstMinY = minSurfaceY - (HORIZON_OFFSET_FROM_GROUND * 0.5);
                    const airburstMaxY = minSurfaceY;
                    bombTargetY = airburstMinY + Math.random() * (airburstMaxY - airburstMinY);
                }

                incomingProjectiles.push(new BombProjectile(startX, startY, targetX, bombTargetY));
            } else if (type === 'massive') {
                // Massive explosion is still a general ground effect
                createExplosion(canvas.width / 2 + (Math.random() * 150 - 75), maxSurfaceY + (Math.random() * (canvas.height - maxSurfaceY)), 'massive');
            }
        }

        // --- Main Animation Loop ---
        function animateFrame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw the simple ground surface
            ctx.fillStyle = GROUND_COLOR;
            ctx.fillRect(0, canvas.height - GROUND_HEIGHT, canvas.width, GROUND_HEIGHT);

            // Draw the horizon line
            const horizonY = canvas.height - GROUND_HEIGHT - HORIZON_OFFSET_FROM_GROUND;
            ctx.beginPath();
            ctx.moveTo(0, horizonY);
            ctx.lineTo(canvas.width, horizonY);
            ctx.strokeStyle = HORIZON_COLOR;
            ctx.lineWidth = HORIZON_THICKNESS;
            ctx.stroke();

            // Update and draw star particles
            starParticles.forEach(p => {
                p.update();
                p.draw();
            });

            // Update and draw Orbital Destroyers
            for (let i = orbitalDestroyers.length - 1; i >= 0; i--) {
                const destroyer = orbitalDestroyers[i];
                destroyer.update();
                destroyer.draw();
            }

            // Draw missile projectiles (bomb, napalm)
            for (let i = incomingProjectiles.length - 1; i >= 0; i--) {
                const proj = incomingProjectiles[i];
                proj.update();
                proj.draw();
                if (proj.hit || proj.opacity <= 0) {
                    incomingProjectiles.splice(i, 1);
                }
            }

            // Draw railgun lines
            for (let i = railgunLines.length - 1; i >= 0; i--) {
                const line = railgunLines[i];
                line.update();
                line.draw();
                if (line.opacity <= 0) {
                    railgunLines.splice(i, 1);
                }
            }

            // Update and draw fire trails (before other particles for layering)
            for (let i = fireTrails.length - 1; i >= 0; i--) {
                const trail = fireTrails[i];
                trail.update();
                trail.draw();
                if (trail.opacity <= 0 || trail.size <= 0.5) {
                    fireTrails.splice(i, 1);
                }
            }

            // Update and draw orbital laser (on top of fire trails)
            if (activeLaser) {
                activeLaser.update();
                activeLaser.draw();
                if (activeLaser.opacity <= 0) {
                    activeLaser = null;
                }
            }

            // Update and draw burn marks (underneath other effects)
            for (let i = burnMarks.length - 1; i >= 0; i--) {
                const mark = burnMarks[i];
                mark.update();
                mark.draw();
                if (mark.opacity <= 0 || mark.radius <= 1) {
                    burnMarks.splice(i, 1);
                }
            }

            for (let i = debrisParticles.length - 1; i >= 0; i--) {
                const p = debrisParticles[i];
                p.update();
                p.draw();
                if (p.opacity <= 0 || p.size <= 0.5) {
                    debrisParticles.splice(i, 1);
                }
            }

            // Draw general explosion particles (before smoke for layering)
            for (let i = explosions.length - 1; i >= 0; i--) {
                const p = explosions[i];
                p.update();
                p.draw();
                if (p.opacity <= 0 || (p.size <= 0.5)) {
                    explosions.splice(i, 1);
                }
            }

            // Draw Napalm Bubbles
            for (let i = napalmBubbles.length - 1; i >= 0; i--) {
                const bubble = napalmBubbles[i];
                bubble.update();
                bubble.draw();
                if (bubble.opacity <= 0) {
                    napalmBubbles.splice(i, 1);
                }
            }

            // Draw smoke particles (on top for realistic smoke)
            for (let i = smokeParticles.length - 1; i >= 0; i--) {
                const p = smokeParticles[i];
                p.update();
                p.draw();
                if (p.opacity <= 0) {
                    smokeParticles.splice(i, 1);
                }
            }

            // New: Update and draw goo particles
            for (let i = gooParticles.length - 1; i >= 0; i--) {
                const p = gooParticles[i];
                p.update();
                p.draw();
                if (p.opacity <= 0 || p.size <= 0.5) {
                    gooParticles.splice(i, 1);
                }
            }

            // Update and draw swarmlings
            for (let i = swarmlings.length - 1; i >= 0; i--) {
                const swarmling = swarmlings[i];
                if (swarmling.update()) { // If update returns true, it's ready for removal
                    swarmlings.splice(i, 1);
                } else {
                    swarmling.draw();
                }
            }

            // Swarmling spawning logic
            const now = Date.now();
            if (isPlaying && now - lastSwarmlingSpawnTime > SWARMLING_SPAWN_INTERVAL) {
                swarmlings.push(new AlienSwarmling());
                lastSwarmlingSpawnTime = now;
            }
            if (isPlaying && now - lastBigSwarmlingSpawnTime > BIG_SWARMLING_SPAWN_INTERVAL) {
                swarmlings.push(new BigSwarmling());
                lastBigSwarmlingSpawnTime = now;
            }

            requestAnimationFrame(animateFrame);
        }

        initDestroyers(); // Initialize destroyers at the start
        initStarParticles(); // Initialize star particles after destroyers are in place

        // --- Chant Animation ---
        const CHANT_DISPLAY_DURATION = 1200; // How long a chant line is fully visible
        const CHANT_FADE_DURATION = 500;    // How long it takes to fade out
        const CHANT_PAUSE_BETWEEN_LINES = 100; // Minimal pause between lines within a stanza

        function displayNextLine() {
            const currentLine = chantLines[currentIndex];
            chantText.textContent = currentLine;
            chantText.classList.add('active');

            // Trigger orbital strikes based on chant line index (simplified)
            // Staggering the type of strike for visual variety
            if (currentLine.includes("HEART - CLEAR") || currentLine.includes("ROGUE V")) {
                triggerOrbitalStrike('bomb'); // Now bombs originate from destroyers
            } else if (currentLine.includes("FATE - NEAR") || currentLine.includes("FREEDOM MUST REVIVE")) {
                triggerOrbitalStrike('laser'); // Trigger orbital laser from destroyer
            } else if (currentLine.includes("STOKE - FEAR") || currentLine.includes("CHAOS REIGNS")) {
                triggerOrbitalStrike('napalm'); // Napalm missile from destroyer
            } else if (currentLine.includes("LET IT BURN!") || currentLine.includes("VERA LIBERTAS!")) {
                triggerOrbitalStrike('railgun'); // Railgun from destroyer
            }

            setTimeout(() => {
                chantText.classList.add('fade');
                setTimeout(() => {
                    chantText.classList.remove('active', 'fade');
                    currentIndex = (currentIndex + 1) % chantLines.length;
                    if (isPlaying) {
                        setTimeout(displayNextLine, CHANT_PAUSE_BETWEEN_LINES); // Consistent short pause
                    } else if (currentIndex === 0) {
                        stopAnimation();
                    }
                }, CHANT_FADE_DURATION);
            }, CHANT_DISPLAY_DURATION);
        }

        function startAnimation() {
            if (!isPlaying) {
                isPlaying = true;
                toggleButton.textContent = 'Ceasefire!';
                displayNextLine();
            }
        }

        function stopAnimation() {
            isPlaying = false;
            toggleButton.textContent = 'Call In Support!';
            chantText.classList.remove('active', 'fade');
            chantText.textContent = '';
            // Clear all active strike particles and reset destroyers
            explosions.length = 0;
            smokeParticles.length = 0;
            debrisParticles.length = 0;
            incomingProjectiles.length = 0; // Clear napalm/bomb missiles
            railgunLines.length = 0; // Clear railgun lines
            napalmBubbles.length = 0;
            fireTrails.length = 0; // Clear fire trails
            activeLaser = null; // Deactivate active laser
            burnMarks.length = 0; // Clear burn marks
            swarmlings.length = 0; // Clear swarmlings
            gooParticles.length = 0; // Clear goo particles
            starParticles.length = 0; // Clear star particles on stop

            // Reset destroyers to their initial state
            orbitalDestroyers.forEach(d => {
                d.x = -d.width - (orbitalDestroyers.indexOf(d) * (canvas.width / MAX_DESTROYERS));
                d.y = Math.random() * (canvas.height * 0.15) + (canvas.height * 0.02);
                d.lastFiredTime = 0; // Reset fire cooldown
            });
            // Re-initialize stars when animation stops and starts again
            initStarParticles();
        }

        startAnimation();
        animateFrame();

        toggleButton.addEventListener('click', () => {
            if (isPlaying) {
                stopAnimation();
            } else {
                startAnimation();
            }
        });
    </script>
</body>
</html>
