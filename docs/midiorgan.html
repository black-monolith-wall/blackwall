<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Tone Player</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            color: #333;
            text-align: center;
            line-height: 1.6;
        }
        .container {
            background-color: #fff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            max-width: 800px;
            width: 90%;
            margin-bottom: 20px;
        }
        h1 {
            color: #000;
            margin-bottom: 15px;
        }
        p {
            margin-bottom: 20px;
        }
        button {
            padding: 12px 25px;
            font-size: 1.1em;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin: 10px 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .message {
            margin-top: 20px;
            font-style: italic;
            color: #555;
        }
        .current-info {
            margin-top: 15px;
            font-size: 1.2em;
            font-weight: bold;
            min-height: 25px;
            color: #000;
        }
        textarea {
            width: calc(100% - 40px);
            height: 300px;
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            resize: vertical;
        }
        .editor-controls {
            margin-top: 10px;
        }
        .warning {
            color: #d9534f;
            font-weight: bold;
        }
        .keyboard-info {
            margin-top: 20px;
            font-size: 0.9em;
            color: #666;
        }
        .recording-indicator {
            display: inline-block;
            width: 15px;
            height: 15px;
            background-color: red;
            border-radius: 50%;
            vertical-align: middle;
            margin-left: 10px;
            animation: pulse 1s infinite alternate;
            display: none;
        }
        @keyframes pulse {
            from { opacity: 1; }
            to { opacity: 0.3; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Custom Tone Player</h1>
        <p>Edit the sequence data below to compose your own tone melody and chords!</p>
        <p class="warning">Remember: This uses raw sine/triangle wave tones. It won't sound like real instruments.</p>

        <button id="playButton">Play Custom Sequence</button>
        <button id="stopButton" disabled>Stop</button>
        <button id="loopButton">Loop: OFF</button>
        <button id="resetButton">Reset Editor</button>
        <button id="saveButton">Save Sequence</button>
        <button id="loadButton">Load Sequence</button>

        <hr>
        <h3>Piano Mode <span class="recording-indicator" id="recordingIndicator"></span></h3>
        <p class="keyboard-info">
            **Lower Octave (Z-M):** `z` (C3), `x` (D3), `c` (E3), `v` (F3), `b` (G3), `n` (A3), `m` (B3)
            <br>
            **Middle Octave (A-L):** `a` (C4), `s` (D4), `d` (E4), `f` (F4), `g` (G4), `h` (A4), `j` (B4), `k` (C5), `l` (D5)
            <br>
            **Higher Octave (Q-P):** `q` (E5), `w` (F5), `e` (G5), `r` (A5), `t` (B5), `y` (C6), `u` (D6), `i` (E6), `o` (F6), `p` (G6)
            <br>
            **Recording Controls:** Press `Enter` to end current segment and start a new one.
        </p>
        <button id="recordButton">Record New Melody</button>
        <button id="stopRecordButton" disabled>Stop Recording</button>
        <button id="clearRecordButton">Clear Recorded Melody</button>
        <button id="addRecordedToEditorButton" disabled>Add Recorded to Editor</button>
        <button id="toggleKeyboardCaptureButton">Toggle Keyboard Capture: ON</button>


        <div class="current-info" id="currentChord"></div>
        <div class="current-info" id="currentNote"></div>
        <div class="message" id="statusMessage">Ready to edit.</div>

        <textarea id="sequenceEditor"></textarea>

        <p>
            <strong>Usage:</strong>
            <br>Each object in the array represents a segment.
            <br>
            `time`: Start time in seconds from the beginning.
            <br>
            `chord`: Name of the chord (e.g., 'Em', 'D', 'B7'). Chords are played with triangle waves.
            <br>
            `duration`: How long the chord/segment lasts.
            <br>
            `melody`: Array of objects `[{name: 'NoteName', duration: X, relativeTime: Y}]`. Melody notes are played with sine waves. `relativeTime` is relative to the segment's `time`.
            <br>
            Valid Note Names: C, C#, D, D#, E, F, F#, G, G#, A, A#, B followed by an octave number (e.g., A4, C5).
            <br>
            <strong>Recording Notes:</strong>
            <br>
            The first note played in a new recording segment, if held for at least 1 second, will be recorded as a chord (with the note name as its root and its held duration). Subsequent notes played *while that chord is held* will become its melody. Otherwise, notes are recorded individually as melody notes with their respective held durations. Press `Enter` to end the current segment and begin a new one.
        </p>
    </div>

    <script>
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let ac;

        let isPlaying = false;
        let isLooping = false;
        let scheduleTimeoutId;
        let currentLoopTimeoutId;

        let isRecording = false;
        let recordedSegments = []; // Stores completed segments: [{time, chord?, duration, melody?}]
        let currentRecordingSegment = null; // The segment currently being built
        let recordStartTime = 0; // AudioContext.currentTime at the start of recording

        const activeOscillators = new Map(); // To keep track of notes being played by keyboard
        const pressedKeys = new Set(); // To track currently pressed keys for debouncing

        let keyboardCaptureEnabled = true; // State for keyboard capture

        const playButton = document.getElementById('playButton');
        const stopButton = document.getElementById('stopButton');
        const loopButton = document.getElementById('loopButton');
        const resetButton = document.getElementById('resetButton');
        const saveButton = document.getElementById('saveButton');
        const loadButton = document.getElementById('loadButton');

        const recordButton = document.getElementById('recordButton');
        const stopRecordButton = document.getElementById('stopRecordButton');
        const clearRecordButton = document.getElementById('clearRecordButton');
        const addRecordedToEditorButton = document.getElementById('addRecordedToEditorButton');
        const toggleKeyboardCaptureButton = document.getElementById('toggleKeyboardCaptureButton');
        const recordingIndicator = document.getElementById('recordingIndicator');

        const statusMessage = document.getElementById('statusMessage');
        const currentChordDisplay = document.getElementById('currentChord');
        const currentNoteDisplay = document.getElementById('currentNote');
        const sequenceEditor = document.getElementById('sequenceEditor');

        // --- Note Name to Frequency Mapping ---
        const noteToFreqMap = {
            'C1': 32.70, 'C#1': 34.65, 'D1': 36.71, 'D#1': 38.89, 'E1': 41.20, 'F1': 43.65, 'F#1': 46.25, 'G1': 48.99, 'G#1': 51.91, 'A1': 55.00, 'A#1': 58.27, 'B1': 61.74,
            'C2': 65.41, 'C#2': 69.30, 'D2': 73.42, 'D#2': 77.78, 'E2': 82.41, 'F2': 87.31, 'F#2': 92.50, 'G2': 97.99, 'G#2': 103.83, 'A2': 110.00, 'A#2': 116.54, 'B2': 123.47,
            'C3': 130.81, 'C#3': 138.59, 'D3': 146.83, 'D#3': 155.56, 'E3': 164.81, 'F3': 174.61, 'F#3': 185.00, 'G3': 196.00, 'G#3': 207.65, 'A3': 220.00, 'A#3': 233.08, 'B3': 246.94,
            'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13, 'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'G4': 392.00, 'G#4': 415.30, 'A4': 440.00, 'A#4': 466.16, 'B4': 493.88,
            'C5': 523.25, 'C#5': 554.37, 'D5': 587.33, 'D#5': 622.25, 'E5': 659.25, 'F5': 698.46, 'F#5': 739.99, 'G5': 783.99, 'G#5': 830.61, 'A5': 880.00, 'A#5': 932.33, 'B5': 987.77,
            'C6': 1046.50, 'C#6': 1108.73, 'D6': 1174.66, 'D#6': 1244.51, 'E6': 1318.51, 'F6': 1396.91, 'F#6': 1479.98, 'G6': 1567.98, 'G#6': 1661.22, 'A6': 1760.00, 'A#6': 1864.66, 'B6': 1975.53,
        };
        function noteToFreq(noteName) {
            return noteToFreqMap[noteName] || 0;
        }

        // --- Chord to Notes Mapping (using note names) ---
        const chordNotesMapping = {
            'Em': ['E3', 'G3', 'B3'],
            'B7': ['B2', 'D#3', 'F#3', 'A3'],
            'D':  ['D3', 'F#3', 'A3'],
            'G':  ['G3', 'B3', 'D4'],
            'Am': ['A2', 'C3', 'E3']
        };

        // --- Default Empty Song Structure ---
        const defaultEmptySequence = [];

        // --- Keyboard to Note Mapping for Piano Mode ---
        const keyboardNoteMap = {
            'z': 'C3', 'x': 'D3', 'c': 'E3', 'v': 'F3', 'b': 'G3', 'n': 'A3', 'm': 'B3',
            'a': 'C4', 's': 'D4', 'd': 'E4', 'f': 'F4', 'g': 'G4', 'h': 'A4', 'j': 'B4', 'k': 'C5', 'l': 'D5',
            'q': 'E5', 'w': 'F5', 'e': 'G5', 'r': 'A5', 't': 'B5', 'y': 'C6', 'u': 'D6', 'i': 'E6', 'o': 'F6', 'p': 'G6'
        };

        // --- Initialize editor with default sequence ---
        function loadDefaultSequence() {
            sequenceEditor.value = JSON.stringify(defaultEmptySequence, null, 2);
            statusMessage.textContent = "Editor cleared. Start recording or add your sequence!";
        }
        loadDefaultSequence();

        // --- Function to play a single tone ---
        function playTone(freq, startTime, duration, type = 'sine', gain = 0.5) {
            if (freq === 0 || duration <= 0) return;

            const oscillator = ac.createOscillator();
            const gainNode = ac.createGain();

            oscillator.type = type;
            oscillator.frequency.setValueAtTime(freq, startTime);

            // Basic ADSR-like envelope for clean start/stop
            const attackTime = 0.01;
            const releaseTime = Math.min(0.05, duration * 0.2); // Release over 50ms or 20% of duration, whichever is smaller

            gainNode.gain.setValueAtTime(0, startTime);
            gainNode.gain.linearRampToValueAtTime(gain, startTime + attackTime);
            gainNode.gain.linearRampToValueAtTime(gain, startTime + duration - releaseTime);
            gainNode.gain.linearRampToValueAtTime(0, startTime + duration);

            oscillator.connect(gainNode);
            gainNode.connect(ac.destination);

            oscillator.start(startTime);
            oscillator.stop(startTime + duration);
        }

        // Function to start a continuous tone (for keyboard input)
        function startTone(freq, type = 'sine', gain = 0.5) {
            if (freq === 0 || activeOscillators.has(freq)) return;

            const oscillator = ac.createOscillator();
            const gainNode = ac.createGain();

            oscillator.type = type;
            oscillator.frequency.setValueAtTime(freq, ac.currentTime);

            gainNode.gain.setValueAtTime(0, ac.currentTime);
            gainNode.gain.linearRampToValueAtTime(gain, ac.currentTime + 0.01);

            oscillator.connect(gainNode);
            gainNode.connect(ac.destination);

            oscillator.start(ac.currentTime);
            activeOscillators.set(freq, { oscillator, gainNode });
        }

        // Function to stop a continuous tone (for keyboard input)
        function stopTone(freq) {
            const tone = activeOscillators.get(freq);
            if (tone) {
                const { oscillator, gainNode } = tone;
                gainNode.gain.linearRampToValueAtTime(0, ac.currentTime + 0.05);
                oscillator.stop(ac.currentTime + 0.1);
                activeOscillators.delete(freq);
            }
        }

        // --- Main Playback Function ---
        function playCustomSequence() {
            if (!ac) {
                ac = new AudioContext();
            }
            if (ac.state === 'suspended') {
                ac.resume();
            }

            let customSequence;
            try {
                customSequence = JSON.parse(sequenceEditor.value);
                if (!Array.isArray(customSequence)) {
                    throw new Error("Input must be a JSON array.");
                }
            } catch (error) {
                statusMessage.textContent = `Error parsing sequence: ${error.message}`;
                console.error("Sequence parsing error:", error);
                return;
            }

            isPlaying = true;
            playButton.disabled = true;
            stopButton.disabled = false;
            resetButton.disabled = true;
            recordButton.disabled = true;
            saveButton.disabled = true;
            loadButton.disabled = true;
            loopButton.disabled = true;
            toggleKeyboardCaptureButton.disabled = true;

            statusMessage.textContent = "Playing...";
            currentChordDisplay.textContent = "";
            currentNoteDisplay.textContent = "";

            const startTime = ac.currentTime; // Actual audio context time when playback starts
            let currentSequenceIndex = 0;
            let maxSequenceEndTime = 0; // Tracks the absolute end time of the last scheduled event

            // Clear any pending timeouts from previous plays
            clearTimeout(scheduleTimeoutId);
            clearTimeout(currentLoopTimeoutId);


            function scheduleNextEvent() {
                if (!isPlaying) {
                    stopPlaybackCleanup(); // Call cleanup to reset UI and state
                    return;
                }

                if (currentSequenceIndex < customSequence.length) {
                    const segment = customSequence[currentSequenceIndex];
                    const segmentTargetTime = startTime + segment.time; // Absolute audio context time for this segment

                    // Update max sequence end time
                    maxSequenceEndTime = Math.max(maxSequenceEndTime, segmentTargetTime + (segment.duration || 0));

                    // Schedule UI updates for chord and note
                    setTimeout(() => {
                        if (isPlaying) {
                            currentChordDisplay.textContent = `Chord: ${segment.chord || '---'}`;
                            currentNoteDisplay.textContent = '---';
                        }
                    }, (segmentTargetTime - ac.currentTime) * 1000);

                    // Play Chord Tones (if defined by a mapped chord or a single note as a chord)
                    if (segment.chord) {
                        let notesToPlay = [];
                        if (chordNotesMapping[segment.chord]) {
                            notesToPlay = chordNotesMapping[segment.chord];
                        } else {
                            // If it's not a predefined chord, assume it's a single note acting as a chord
                            notesToPlay = [segment.chord];
                        }

                        const chordGain = 0.2;
                        notesToPlay.forEach(noteName => {
                            playTone(noteToFreq(noteName), segmentTargetTime, segment.duration, 'triangle', chordGain);
                        });
                    }

                    // Play Melody Tones
                    if (segment.melody && Array.isArray(segment.melody) && segment.melody.length > 0) {
                        const melodyGain = 0.35;
                        segment.melody.forEach(melodyNote => {
                            const noteName = melodyNote.name;
                            const noteDuration = melodyNote.duration || 0.1; // Default to 0.1s if no duration
                            const noteRelativeTime = melodyNote.relativeTime || 0; // Default to 0 if no relativeTime

                            const notePlayTime = segmentTargetTime + noteRelativeTime; // Absolute time for this melody note

                            playTone(noteToFreq(noteName), notePlayTime, noteDuration, 'sine', melodyGain);

                            setTimeout(() => {
                                if (isPlaying) currentNoteDisplay.textContent = `Melody: ${noteName}`;
                            }, (notePlayTime - ac.currentTime) * 1000);
                        });
                    }

                    currentSequenceIndex++;

                    // Schedule the next segment or end the sequence
                    const nextSegment = customSequence[currentSequenceIndex];
                    if (nextSegment) {
                        const nextSegmentRelativeTime = nextSegment.time;
                        const currentPlaybackTime = ac.currentTime - startTime;
                        const delayUntilNextSegmentMs = (nextSegmentRelativeTime - currentPlaybackTime) * 1000;

                        scheduleTimeoutId = setTimeout(scheduleNextEvent, Math.max(0, delayUntilNextSegmentMs)); // Ensure delay is not negative
                    } else {
                        // All segments scheduled, wait for the last note to finish
                        const currentPlaybackTime = ac.currentTime - startTime;
                        const remainingTimeMs = (maxSequenceEndTime - currentPlaybackTime) * 1000;

                        currentLoopTimeoutId = setTimeout(() => {
                            if (isPlaying) {
                                if (isLooping) {
                                    statusMessage.textContent = "Looping...";
                                    currentSequenceIndex = 0;
                                    playCustomSequence(); // Restart the sequence
                                } else {
                                    isPlaying = false; // Stop playback
                                    stopPlaybackCleanup();
                                    statusMessage.textContent = "Sequence finished.";
                                }
                            }
                        }, Math.max(0, remainingTimeMs + 50)); // Add a small buffer
                    }
                }
            }

            scheduleNextEvent();
        }

        // --- Stop Playback Function ---
        function stopPlayback() {
            isPlaying = false;
            stopPlaybackCleanup();
        }

        function stopPlaybackCleanup() {
            clearTimeout(scheduleTimeoutId);
            clearTimeout(currentLoopTimeoutId);
            // Stop all currently playing oscillators
            activeOscillators.forEach((tone, freq) => stopTone(freq));
            pressedKeys.clear();

            if (ac && ac.state === 'running') {
                ac.suspend();
            }
            // A slight delay to ensure AudioContext settles before attempting resume for next play
            setTimeout(() => {
                if (ac) ac.resume();
            }, 100);

            // Reset UI and button states
            playButton.disabled = false;
            stopButton.disabled = true;
            resetButton.disabled = false;
            recordButton.disabled = false;
            saveButton.disabled = false;
            loadButton.disabled = false;
            loopButton.disabled = false;
            toggleKeyboardCaptureButton.disabled = false;
            currentChordDisplay.textContent = "";
            currentNoteDisplay.textContent = "";
            statusMessage.textContent = "Stopped.";
        }

        // --- Recording Logic ---
        function startNewRecordingSegment() {
            // Finalize previous segment if it exists and is not empty
            if (currentRecordingSegment &&
                (currentRecordingSegment.melody.length > 0 || (currentRecordingSegment.chord && currentRecordingSegment.chord.name))) {

                let segmentEnd = currentRecordingSegment.startTime; // Initialize with segment start

                // Update segment duration based on chord or last melody note
                if (currentRecordingSegment.chord && currentRecordingSegment.chord.duration) {
                    segmentEnd = Math.max(segmentEnd, currentRecordingSegment.chord.startTime + currentRecordingSegment.chord.duration);
                }
                currentRecordingSegment.melody.forEach(note => {
                    segmentEnd = Math.max(segmentEnd, note.startTime + note.duration);
                });

                currentRecordingSegment.duration = parseFloat((segmentEnd - currentRecordingSegment.startTime).toFixed(3));
                if (currentRecordingSegment.duration < 0.05) currentRecordingSegment.duration = 0.05; // Minimum duration

                recordedSegments.push(currentRecordingSegment);
                statusMessage.textContent = `Recorded segment ended. New segment started.`;
            } else if (currentRecordingSegment) {
                // If a segment was started but nothing was recorded, don't add it.
                statusMessage.textContent = `Empty segment skipped. New segment started.`;
            }

            // Start a new empty segment relative to the start of recording
            currentRecordingSegment = {
                time: parseFloat((ac.currentTime - recordStartTime).toFixed(3)),
                melody: []
            };
        }

        function startRecording() {
            if (!ac) {
                ac = new AudioContext();
            }
            if (ac.state === 'suspended') {
                ac.resume();
            }
            isRecording = true;
            recordedSegments = [];
            recordStartTime = ac.currentTime;
            currentRecordingSegment = null; // Will be initialized by the first key press

            recordButton.disabled = true;
            stopRecordButton.disabled = false;
            playButton.disabled = true;
            clearRecordButton.disabled = true;
            addRecordedToEditorButton.disabled = true;
            toggleKeyboardCaptureButton.disabled = true;
            recordingIndicator.style.display = 'inline-block';
            statusMessage.textContent = "Recording... (Press first note, hold 1s for chord. Enter for new segment)";
        }

        function stopRecording() {
            isRecording = false;
            if (currentRecordingSegment) { // Finalize the last segment if it exists
                startNewRecordingSegment(); // This also pushes the last segment
                currentRecordingSegment = null;
            }

            recordButton.disabled = false;
            stopRecordButton.disabled = true;
            playButton.disabled = false;
            clearRecordButton.disabled = false;
            addRecordedToEditorButton.disabled = (recordedSegments.length === 0);
            toggleKeyboardCaptureButton.disabled = false;
            recordingIndicator.style.display = 'none';

            if (recordedSegments.length > 0) {
                statusMessage.textContent = `Recording stopped. ${recordedSegments.length} segments recorded.`;
            } else {
                statusMessage.textContent = "Recording stopped. No segments recorded.";
            }
        }

        function clearRecordedMelody() {
            recordedSegments = [];
            currentRecordingSegment = null;
            statusMessage.textContent = "Recorded melody cleared.";
            addRecordedToEditorButton.disabled = true;
        }

        function addRecordedToEditor() {
            if (recordedSegments.length === 0) {
                statusMessage.textContent = "No melody recorded to add.";
                return;
            }

            let currentEditorSequence;
            try {
                currentEditorSequence = JSON.parse(sequenceEditor.value);
                if (!Array.isArray(currentEditorSequence)) {
                    throw new Error("Editor content is not a valid JSON array.");
                }
            } catch (error) {
                statusMessage.textContent = `Error reading editor content: ${error.message}. Please fix or reset.`;
                console.error("Editor content error:", error);
                return;
            }

            // Determine the total duration of the existing sequence to append new segments correctly
            let existingSequenceDuration = 0;
            currentEditorSequence.forEach(item => {
                if (item.time !== undefined && item.duration !== undefined) {
                    existingSequenceDuration = Math.max(existingSequenceDuration, item.time + item.duration);
                }
            });

            // Adjust the time of recorded segments relative to the end of the existing sequence
            const newSegmentsToAdd = recordedSegments.map(segment => {
                const newTime = existingSequenceDuration + segment.time + (existingSequenceDuration > 0 ? 0.1 : 0); // Add a small gap after first segment if not empty
                const newSegment = { time: parseFloat(newTime.toFixed(3)) };

                if (segment.chord && segment.chord.name) {
                    newSegment.chord = segment.chord.name;
                    newSegment.duration = parseFloat(segment.duration.toFixed(3)); // Chord's duration determines segment duration
                } else {
                    newSegment.duration = parseFloat(segment.duration.toFixed(3));
                }

                if (segment.melody && segment.melody.length > 0) {
                    newSegment.melody = segment.melody.map(note => ({
                        name: note.name,
                        duration: parseFloat(note.duration.toFixed(3)),
                        relativeTime: parseFloat(note.relativeTime.toFixed(3))
                    }));
                }
                return newSegment;
            });

            currentEditorSequence.push(...newSegmentsToAdd);
            sequenceEditor.value = JSON.stringify(currentEditorSequence, null, 2);
            statusMessage.textContent = "Recorded melody added to editor. Remember to save if you want to keep it!";
            recordedSegments = []; // Clear recorded data after adding to editor
            addRecordedToEditorButton.disabled = true;
        }

        // --- Save/Load Functions ---
        function saveSequence() {
            try {
                const sequenceToSave = sequenceEditor.value;
                JSON.parse(sequenceToSave);
                localStorage.setItem('customToneSequence', sequenceToSave);
                statusMessage.textContent = "Sequence saved to browser's local storage.";
            } catch (error) {
                statusMessage.textContent = `Error saving sequence: ${error.message}`;
                console.error("Save error:", error);
            }
        }

        function loadSequence() {
            const savedSequence = localStorage.getItem('customToneSequence');
            if (savedSequence) {
                try {
                    JSON.parse(savedSequence);
                    sequenceEditor.value = savedSequence;
                    statusMessage.textContent = "Sequence loaded from browser's local storage.";
                } catch (error) {
                    statusMessage.textContent = `Error loading sequence (corrupted data): ${error.message}. Editor cleared.`;
                    console.error("Load error:", error);
                    loadDefaultSequence();
                }
            } else {
                statusMessage.textContent = "No saved sequence found in local storage.";
            }
        }

        // --- Event Listeners ---
        playButton.addEventListener('click', () => playCustomSequence());
        stopButton.addEventListener('click', stopPlayback);
        resetButton.addEventListener('click', loadDefaultSequence);
        saveButton.addEventListener('click', saveSequence);
        loadButton.addEventListener('click', loadSequence);

        loopButton.addEventListener('click', () => {
            isLooping = !isLooping;
            loopButton.textContent = `Loop: ${isLooping ? 'ON' : 'OFF'}`;
            if (isPlaying && isLooping && statusMessage.textContent.includes("finished.")) {
                playCustomSequence(); // Restart if finished and looping is turned on
            } else if (isPlaying && !isLooping) {
                // If looping is turned off mid-play, ensure the current loop timeout is cleared
                clearTimeout(currentLoopTimeoutId);
            }
            statusMessage.textContent = `Looping is now ${isLooping ? 'ON' : 'OFF'}.`;
        });

        // Toggle Keyboard Capture
        toggleKeyboardCaptureButton.addEventListener('click', () => {
            keyboardCaptureEnabled = !keyboardCaptureEnabled;
            toggleKeyboardCaptureButton.textContent = `Toggle Keyboard Capture: ${keyboardCaptureEnabled ? 'ON' : 'OFF'}`;
            statusMessage.textContent = `Keyboard capture is now ${keyboardCaptureEnabled ? 'ON' : 'OFF'}.`;
            // Clear any active notes if capture is turned off mid-play
            if (!keyboardCaptureEnabled) {
                activeOscillators.forEach((tone, freq) => stopTone(freq));
                pressedKeys.clear();
            }
        });

        // Keyboard Event Listeners
        document.addEventListener('keydown', (e) => {
            if (!keyboardCaptureEnabled || e.repeat) return; // Prevent continuous notes on key hold

            const key = e.key.toLowerCase();

            if (isRecording && e.key === 'Enter') {
                e.preventDefault(); // Prevent new line in text area if focused
                startNewRecordingSegment();
                return;
            }

            const noteName = keyboardNoteMap[key];

            if (noteName && !pressedKeys.has(key)) {
                e.preventDefault(); // Prevent default browser actions for these keys
                pressedKeys.add(key);

                if (!ac) {
                    ac = new AudioContext();
                }
                if (ac.state === 'suspended') {
                    ac.resume();
                }
                const freq = noteToFreq(noteName);
                if (freq) {
                    startTone(freq, 'sine', 0.5);
                    if (isRecording) {
                        const currentTime = ac.currentTime - recordStartTime;
                        if (!currentRecordingSegment) {
                            startNewRecordingSegment();
                            // If this is the very first note of the entire recording, adjust segment time to 0
                            if (recordedSegments.length === 0) {
                                currentRecordingSegment.time = 0;
                            }
                        }

                        // Check if this is the first note of the current segment for chord detection
                        const isFirstNoteOfSegment = !currentRecordingSegment.chord && currentRecordingSegment.melody.length === 0 && !currentRecordingSegment._potentialChord;

                        if (isFirstNoteOfSegment) {
                            currentRecordingSegment._potentialChord = {
                                name: noteName,
                                startTime: currentTime,
                                timeoutId: setTimeout(() => {
                                    // If held for 1 second, confirm it's a chord
                                    currentRecordingSegment.chord = {
                                        name: noteName,
                                        startTime: currentRecordingSegment._potentialChord.startTime, // Relative to recording start
                                        duration: 0 // Will be updated on keyup
                                    };
                                    statusMessage.textContent = `Recording: Chord ${noteName} held. Play melody over it.`;
                                    delete currentRecordingSegment._potentialChord; // No longer just potential
                                }, 1000)
                            };
                            currentNoteDisplay.textContent = `Playing: ${noteName} (Potential Chord)`;
                        } else if (currentRecordingSegment.chord) {
                            // Already a chord, add subsequent notes as melody over the chord
                            currentRecordingSegment.melody.push({
                                name: noteName,
                                relativeTime: parseFloat((currentTime - currentRecordingSegment.chord.startTime).toFixed(3)),
                                startTime: currentTime, // Absolute time for duration calculation
                                duration: 0 // Will be updated on keyup
                            });
                            currentNoteDisplay.textContent = `Melody: ${noteName}`;
                        } else {
                            // Not a chord, just a regular melody note in a melody-only segment
                            currentRecordingSegment.melody.push({
                                name: noteName,
                                relativeTime: parseFloat((currentTime - currentRecordingSegment.time).toFixed(3)), // Relative to segment start
                                startTime: currentTime, // Absolute time for duration calculation
                                duration: 0
                            });
                            currentNoteDisplay.textContent = `Melody: ${noteName}`;
                        }
                    }
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (!keyboardCaptureEnabled) return;

            const key = e.key.toLowerCase();
            const noteName = keyboardNoteMap[key];

            if (noteName && pressedKeys.has(key)) {
                pressedKeys.delete(key);

                const freq = noteToFreq(noteName);
                if (freq) {
                    stopTone(freq);
                    if (isRecording && currentRecordingSegment) {
                        const currentTime = ac.currentTime - recordStartTime;

                        // Check if it's the chord note being released
                        if (currentRecordingSegment.chord && currentRecordingSegment.chord.name === noteName &&
                            currentRecordingSegment.chord.duration === 0) { // Check if its duration hasn't been set yet
                            currentRecordingSegment.chord.duration = parseFloat((currentTime - currentRecordingSegment.chord.startTime).toFixed(3));
                            if (currentRecordingSegment.chord.duration < 0.05) currentRecordingSegment.chord.duration = 0.05; // Minimum duration
                            statusMessage.textContent = `Recording: Chord ${noteName} released.`;

                            // Also ensure all melody notes active *during* this chord are finalized
                            currentRecordingSegment.melody.forEach(note => {
                                if (note.duration === 0) { // If note hasn't been released yet
                                    note.duration = parseFloat((currentTime - note.startTime).toFixed(3));
                                    if (note.duration < 0.05) note.duration = 0.05; // Minimum duration
                                }
                            });
                        } else if (currentRecordingSegment._potentialChord && currentRecordingSegment._potentialChord.name === noteName) {
                            // Potential chord released before 1 second confirmation
                            clearTimeout(currentRecordingSegment._potentialChord.timeoutId);
                            const duration = parseFloat((currentTime - currentRecordingSegment._potentialChord.startTime).toFixed(3));
                            // Add it as a regular melody note instead
                            currentRecordingSegment.melody.push({
                                name: noteName,
                                relativeTime: parseFloat((currentRecordingSegment._potentialChord.startTime - currentRecordingSegment.time).toFixed(3)),
                                startTime: currentRecordingSegment._potentialChord.startTime,
                                duration: duration
                            });
                            if (duration < 0.05) currentRecordingSegment.melody[currentRecordingSegment.melody.length - 1].duration = 0.05;
                            statusMessage.textContent = `Recording: Note ${noteName} released.`;
                            delete currentRecordingSegment._potentialChord;
                        } else {
                            // Regular melody note released
                            // Find the most recent, un-ended melody note with this name
                            const melodyNote = currentRecordingSegment.melody.findLast(note => note.name === noteName && note.duration === 0);
                            if (melodyNote) {
                                melodyNote.duration = parseFloat((currentTime - melodyNote.startTime).toFixed(3));
                                if (melodyNote.duration < 0.05) melodyNote.duration = 0.05; // Minimum duration
                                currentNoteDisplay.textContent = `Note: ${noteName} released.`;
                            }
                        }
                    }
                }
            }
        });


        // Recording button listeners
        recordButton.addEventListener('click', startRecording);
        stopRecordButton.addEventListener('click', stopRecording);
        clearRecordButton.addEventListener('click', clearRecordedMelody);
        addRecordedToEditorButton.addEventListener('click', addRecordedToEditor);

        // Initial setup for buttons
        playButton.disabled = false;
        stopButton.disabled = true;
        stopRecordButton.disabled = true;
        addRecordedToEditorButton.disabled = true;
    </script>
</body>
</html>
